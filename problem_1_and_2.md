# 算法题解答

## 题目 1: 反向对称矩阵–向量乘法

#### 1. 算法设计 (伪代码)

**问题分析**

给定一个 $n \times n$ 的反向对称矩阵 $A$ (也称为 Hankel 矩阵)，其元素由一个长度为 $2n-1$ 的压缩向量 $a = [a_0, a_1, \dots, a_{2n-2}]$ 定义，其中 $A_{i,j} = a_{n-1+i-j}$。我们需要计算矩阵-向量乘积 $y = A \cdot v$。

$y$ 的第 $i$ 个元素 $(y_i)$ 计算公式为：
$$y_i = \sum_{j=0}^{n-1} A_{i,j} v_j = \sum_{j=0}^{n-1} a_{n-1+i-j} v_j$$

这个求和的形式非常接近卷积。一个离散卷积 $(f * g)_k$ 的定义是 $\sum_j f_j g_{k-j}$。为了将我们的问题转化为标准卷积形式，我们对其中一个向量进行翻转。

令向量 $v$ 的翻转版本为 $v^{rev}$，即 $v^{rev}_k = v_{n-1-k}$。
令压缩向量为 $h$，即 $h_k = a_k$。

重写 $y_i$ 的公式：
令 $k=n-1-j$, 则 $j=n-1-k$。当 $j$ 从 $0$ 遍历到 $n-1$ 时，$k$ 从 $n-1$ 遍历到 $0$。
$$y_i = \sum_{k=0}^{n-1} a_{n-1+i-(n-1-k)} v_{n-1-k} = \sum_{k=0}^{n-1} a_{i+k} v^{rev}_k$$

这个形式 $C_i = \sum_k h_{i+k} g_k$ 是一个非循环卷积的一部分。我们可以通过快速傅里叶变换 (FFT) 来高效计算这个卷积。

---

**算法 1: 朴素算法**

直接根据定义进行计算。

```pseudocode
function NaiveMatrixVectorProduct(a, v, n):
  // a: 压缩表示, 长度 2n-1
  // v: 输入向量, 长度 n
  // n: 矩阵维度

  y = new array of size n, initialized to 0

  for i from 0 to n-1:
    for j from 0 to n-1:
      // A[i,j] = a[n-1 + i - j]
      y[i] = y[i] + a[n-1 + i - j] * v[j]

  return y
```

**算法 2: 基于 FFT 的快速算法**

利用卷积定理，通过 FFT 将时域的卷积运算转换为频域的乘积运算。

```pseudocode
function FastMatrixVectorProduct(a, v, n):
  // a: 压缩表示 h, 长度 2n-1
  // v: 输入向量, 长度 n

  // 1. 准备序列
  h = a
  v_rev = reverse(v) // v_rev[k] = v[n-1-k]

  // 2. 补零以进行线性卷积
  // 卷积结果长度为 (len(h) + len(v_rev) - 1) = (2n-1 + n - 1) = 3n-2
  N = next_power_of_2(3n - 2)
  h_padded = pad h with zeros to length N
  v_rev_padded = pad v_rev with zeros to length N

  // 3. 执行 FFT
  H_fft = FFT(h_padded)
  V_rev_fft = FFT(v_rev_padded)

  // 4. 在频域中进行元素级乘积
  C_fft = element_wise_product(H_fft, V_rev_fft)

  // 5. 执行逆 FFT
  c = IFFT(C_fft)

  // 6. 提取结果
  // y_i = c_i for i in [0, n-1]
  y = first n elements of c

  return y
```

---

#### 2. 复杂度分析

**朴素算法**
该算法包含两个嵌套循环，每个循环的迭代次数都为 $n$。因此，时间复杂度为 $O(n^2)$。

**基于 FFT 的快速算法**
1.  **准备序列**: 翻转向量 $v$ 需要 $O(n)$。
2.  **补零**: 补零操作需要 $O(N)$。$N$ 是大于等于 $3n-2$ 的最小的2的幂，所以 $N < 2 \cdot (3n-2) = 6n-4$。因此 $N = O(n)$。
3.  **FFT**: 对两个长度为 $N$ 的序列执行 FFT 的时间复杂度为 $O(N \log N)$。
4.  **元素级乘积**: 需要 $O(N)$。
5.  **逆 FFT**: 对一个长度为 $N$ 的序列执行 IFFT 的时间复杂度为 $O(N \log N)$。
6.  **提取结果**: 需要 $O(n)$。

由于 $N=O(n)$，算法的瓶颈在于 FFT 和 IFFT 步骤。因此，总的时间复杂度上界为 **$O(n \log n)$**。

## 题目 2: 使用 FFT 进行正则匹配

#### 1. 算法实现

**问题分析**

我们需要在主串 $S$ (长度 $n$) 中查找模式串 $P$ (长度 $m$) 的所有匹配位置。$P$ 中可以包含通配符 `?`。

如果模式串在 $S$ 的位置 $k$ 匹配，那么对于所有 $j \in [0, m-1]$，必须满足以下条件之一：
1.  $P[j] = '?'$
2.  $P[j] = S[k+j]$

我们可以设计一个"失配度"函数 $M(k)$，当且仅当在位置 $k$ 发生完全匹配时，$M(k)=0$。一个常用的方法是利用平方差：

$$M(k) = \sum_{j=0}^{m-1} \mathbb{I}(P[j] \neq '?') \cdot (S[k+j] - P[j])^2$$

其中 $\mathbb{I}(\cdot)$ 是指示函数（条件为真时为1，否则为0）。为了进行计算，我们需要将字符映射为数字。

展开上式：
$$M(k) = \sum_{j=0}^{m-1} W_j \cdot (S_{k+j}^2 - 2 S_{k+j} P_j + P_j^2)$$
$$M(k) = \sum_{j=0}^{m-1} W_j S_{k+j}^2 - 2 \sum_{j=0}^{m-1} (W_j P_j) S_{k+j} + \sum_{j=0}^{m-1} W_j P_j^2$$

其中，$P_j$ 是 $P[j]$ 的数值表示， $W_j$ 是一个权重（如果 $P[j] \neq '?'$ 则为1，否则为0）。

我们分析这三项：
1.  **$\sum_{j=0}^{m-1} W_j P_j^2$**: 这是一个常数，只与模式串 $P$ 有关，可以预先计算。
2.  **$\sum_{j=0}^{m-1} (W_j P_j) S_{k+j}$**: 这是一个卷积。令 $P'(j) = W_j P_j$，并将其翻转得到 $P'_{rev}(j) = P'(m-1-j)$。该项就是 $S$ 和 $P'_{rev}$ 的卷积在 $k+m-1$ 处的值。
3.  **$\sum_{j=0}^{m-1} W_j S_{k+j}^2$**: 这也是一个卷积。令 $S^2(i) = S_i^2$，并将 $W$ 翻转得到 $W_{rev}(j) = W_{m-1-j}$。该项就是 $S^2$ 和 $W_{rev}$ 的卷积在 $k+m-1$ 处的值。

因此，我们可以通过两次 FFT 来计算所有位置 $k$ 的 $M(k)$ 值。

---

**算法流程**

1.  **预处理**:
    a.  将主串 $S$ 和模式串 $P$ 中的字符映射为整数 (例如，'a'->1, 'b'->2, ...)。
    b.  创建数值向量 $S_{num}$ (长度 $n$) 和 $P_{num}$ (长度 $m$)。
    c.  创建权重向量 $W$ (长度 $m$)：若 $P[j] \neq '?'$，$W[j]=1$；否则 $W[j]=0$。将 $P$ 中的 '?' 在 $P_{num}$ 中对应的位置设为 0。
    d.  创建 $S_{sq}$ 向量：$S_{sq}[i] = S_{num}[i]^2$。
    e.  创建两个用于卷积的翻转模式串：
        - `P_conv = reverse(W * P_num)` (element-wise product)
        - `W_conv = reverse(W)`
    f.  计算常数项 `Term3 = sum(W * P_num^2)`。

2.  **FFT 卷积**:
    a.  选择 FFT 的长度 $N$，使其为大于等于 $n+m-1$ 的最小的2的幂。
    b.  计算 `Term1_conv = IFFT(FFT(S_sq, N) * FFT(W_conv, N))`。
    c.  计算 `Term2_conv = IFFT(FFT(S_num, N) * FFT(P_conv, N))`。

3.  **计算失配度**:
    a.  初始化一个结果数组 `matches`。
    b.  对于所有可能的起始位置 $k \in [0, n-m]$:
        i.  从卷积结果中提取相应的值：
            - `term1 = Term1_conv[k+m-1]`
            - `term2 = Term2_conv[k+m-1]`
        ii. 计算 $M(k) = \text{term1} - 2 \cdot \text{term2} + \text{Term3}$。
        iii. 由于浮点数精度问题，检查 `abs(M(k))` 是否小于一个很小的阈值 (如 `1e-6`)。如果是，则在 `matches` 中添加位置 $k$。

4.  **返回结果**: 返回 `matches` 数组。

---

#### 2. 时间复杂度分析

-   **预处理**: 创建 $S_{num}, P_{num}, W, S_{sq}, P_{conv}, W_{conv}$ 都需要 $O(n+m)$ 的时间。
-   **FFT 卷积**: 包含两次 FFT、两次 IFFT 和两次元素级乘积。FFT 的长度 $N=O(n)$ (因为 $n \gg m$)。所以这部分的复杂度是 $O(n \log n)$。
-   **计算失配度**: 循环遍历 $n-m+1$ 个位置，每次都是 $O(1)$ 的计算。总共是 $O(n)$。

综上，算法的瓶颈是 FFT 卷积，所以总时间复杂度为 **$O(n \log n)$**。

---

#### 3. 优化想法

1.  **减少 FFT 次数**: 虽然上述方法需要两次卷积 (三次FFT，因为 `FFT(S_num)` 可以复用)，但这是该问题数值解法的标准形式。根本性的优化很难。但在特定条件下，例如字母表非常小，可以采用不同的策略。

2.  **小字母表优化**: 如果字母表 $\Sigma$ 很小 (例如，只包含 'A', 'C', 'G', 'T')，我们可以为每个字符 `c` 创建一个二元串。
    -   $S_c[i] = 1$ if $S[i] = c$, else $0$.
    -   $P_c[j] = 1$ if $P[j] = c$, else $0$.
    -   字符 `c` 在位置 $k$ 的匹配数可以通过计算 $S_c$ 和翻转后的 $P_c$ 的卷积得到。
    -   总匹配数是所有字符匹配数之和：$\sum_{c \in \Sigma} \text{conv}(S_c, \text{rev}(P_c))$。
    -   总匹配数如果等于 $P$ 中非通配符的数量，则该位置匹配成功。
    -   这个方法的复杂度是 $O(|\Sigma| \cdot n \log n)$。当 $|\Sigma|$ 非常小时，这可能是有效的。但对于普通文本（如 ASCII），$|\Sigma|$ 很大，此方法不适用。

3.  **分块处理 (Block Processing)**: 如果主串 $S$ 巨大，无法一次性读入内存，可以将其切分为重叠的块进行处理。例如，将 $S$ 切分为长度为 $2m$ 的块，每个块之间重叠 $m-1$ 的长度。这样可以独立处理每个块，降低内存峰值，也易于并行化。这不改变总体时间复杂度，但优化了空间复杂度和实际执行效率。

4.  **硬件加速**: FFT 算法是高度可并行的。使用 GPU (例如通过 CUDA 的 cuFFT 库) 可以极大地加速计算过程，特别是对于非常大的 $n$。