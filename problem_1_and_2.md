# 算法题解

## 题目 1: 反向对称矩阵与向量的高效乘法

### 问题描述

给定一个 $n \times n$ 的 **托普利茨矩阵 (Toeplitz Matrix)** $A$，其定义为矩阵中任意从左上到右下的对角线上的元素均相等，即 $A_{i,j} = A_{i+1, j+1}$。该矩阵可以由一个长度为 $2n-1$ 的数组 $a = (a_0, a_1, \dots, a_{2n-2})$ 压缩表示，其中 $A_{i,j} = a_{n-1+i-j}$。

任务是设计一个算法，计算矩阵-向量乘积 $y = A \cdot v$，并分析其时间复杂度。

### 算法设计

朴素的矩阵-向量乘法需要 $O(n^2)$ 次运算。利用托普利茨矩阵的特殊结构，我们可以将此乘法问题转化为多项式卷积问题，并通过快速傅里叶变换 (FFT) 在 $O(n \log n)$ 时间内解决。

#### 1. 卷积的识别

$y = A \cdot v$ 的第 $i$ 个元素 $(i=0, \dots, n-1)$ 定义为：
$$y_i = \sum_{j=0}^{n-1} A_{i,j} v_j = \sum_{j=0}^{n-1} a_{n-1+i-j} v_j$$

这个求和的形式与卷积非常相似。为了将其转化为标准卷积形式 $(\sum c_k x_{i-k})$，我们对向量 $v$ 进行逆序，定义一个新向量 $v'$，其中 $v'_{k} = v_{n-1-k}$。将 $j = n-1-k$ 代入上式：
$$y_i = \sum_{k=0}^{n-1} a_{n-1+i-(n-1-k)} v'_{k} = \sum_{k=0}^{n-1} a_{i+k} v'_{k}$$

#### 2. 多项式乘法形式

上述求和可以看作是两个多项式乘积的系数。我们定义两个多项式：
-   $C(x) = a_0 + a_1 x + \dots + a_{2n-2} x^{2n-2}$
-   $V(x) = v'_{0} + v'_{1} x + \dots + v'_{n-1} x^{n-1}$

它们的乘积 $P(x) = C(x) \cdot V(x)$ 的第 $m$ 项系数为 $\sum_{k=0}^{m} c_k v'_{m-k}$。
观察我们的目标公式 $y_i = \sum_{k=0}^{n-1} a_{i+k} v'_{k}$，可以发现 $y_i$ 恰好是多项式 $(a_0 + a_1 x + \dots) \cdot (v'_0 + v'_1 x^{-1} + \dots)$ 中 $x^{-i}$ 项的系数。

为了使用标准的 FFT 多项式乘法，我们构造如下两个多项式的系数向量：
1.  **`a_poly`**: `[a_0, a_1, ..., a_{2n-2}]`
2.  **`v_rev_poly`**: `[v_{n-1}, v_{n-2}, ..., v_0]` (即 $v$ 的逆序)

设这两个系数向量相乘（卷积）的结果为 `res_poly`。那么，我们所求的 $y_i$ 就对应 `res_poly` 中的第 $n-1+i$ 个系数。

#### 3. 算法步骤

1.  **构造**:
    *   取压缩数组 `a` 作为第一个多项式的系数。
    *   将输入向量 `v` 逆序得到 `v_rev`，作为第二个多项式的系数。
2.  **填充**:
    *   确定 FFT 所需的长度 `N`。乘积多项式的最高次为 $(2n-2) + (n-1) = 3n-3$，因此需要至少 $3n-2$ 个点。取 `N` 为大于等于 $3n-2$ 的最小的 2 的幂。
    *   将 `a` 和 `v_rev` 用零填充至长度 `N`。
3.  **FFT**:
    *   计算 `fft_a = FFT(a_padded)`。
    *   计算 `fft_v = FFT(v_rev_padded)`。
4.  **逐点相乘**:
    *   计算频域乘积 `fft_prod = fft_a * fft_v`。
5.  **逆 FFT**:
    *   计算 `res_poly = IFFT(fft_prod)`，得到卷积结果的系数向量。
6.  **提取结果**:
    *   输出向量 `y` 的第 `i` 个元素 `y[i]` 为 `res_poly[n-1+i]`，其中 $i=0, \dots, n-1$。

### 复杂度分析

-   **构造与填充**: $O(n)$
-   **FFT/IFFT**: 长度为 $N$ 的 FFT 复杂度为 $O(N \log N)$。
-   **频域相乘**: $O(N)$
-   **结果提取**: $O(n)$

由于 $N$ 被选为 $O(n)$ 级别的 2 的幂（具体来说 $N < 2 \times (3n-2)$），算法的瓶颈在于 FFT 和 IFFT 步骤。因此，**总体时间复杂度为 $O(n \log n)$**。

---

## 题目 2: 基于 FFT 的通配符字符串匹配

### 问题描述

给定一个主串 $S$ (长度 $n$) 和一个模式串 $P$ (长度 $m$)，其中 $P$ 可能包含通配符 `?`，该通配符可以匹配任意单个字符。要求设计一个算法，找出 $P$ 在 $S$ 中所有匹配的起始位置。

### 算法设计

核心思想是将字符匹配问题转化为一个数值计算问题，使得匹配位置的某个“差异度”为零。

#### 1. 定义差异度函数

我们希望构造一个函数 $D(k)$，当且仅当 $P$ 与 $S$ 的子串 $S[k:k+m]$ 匹配时，$D(k)=0$。

首先，将字符映射为非零整数 (e.g., a->1, b->2, ...)，并将通配符 `?` 映射为 0。令 $s(i)$ 和 $p(j)$ 分别为 $S[i]$ 和 $P[j]$ 的数值。

一个成功的匹配发生在位置 $k$，当且仅当对所有 $j \in [0, m-1]$，要么 $P[j] = '?'$，要么 $s(k+j) = p(j)$。这等价于以下条件：
$$\sum_{j=0}^{m-1} (s(k+j) - p(j))^2 \cdot p_{mask}(j) = 0$$
其中 $p_{mask}(j)$ 是一个掩码，当 $P[j] \neq '?'$ 时为 1，否则为 0。（我们令 $p(j)=0$ 当 $P[j] = '?'$，这样 $(s(k+j)-p(j))^2$ 在通配符位置的计算不会影响结果，因为会被 $p_{mask}(j)$ 乘零）。

#### 2. 展开为卷积形式

展开差异度函数 $D(k)$:
$$D(k) = \sum_{j=0}^{m-1} [s(k+j)^2 - 2s(k+j)p(j) + p(j)^2] \cdot p_{mask}(j)$$
$$D(k) = \underbrace{\sum_{j=0}^{m-1} s(k+j)^2 p_{mask}(j)}_{\text{Term A}} - 2\underbrace{\sum_{j=0}^{m-1} s(k+j)p(j)}_{\text{Term B}} + \underbrace{\sum_{j=0}^{m-1} p(j)^2 p_{mask}(j)}_{\text{Term C}}$$

-   **Term C**: 这是一个常数，只依赖于模式串 $P$，可以预先计算。
-   **Term A 和 Term B**: 这两项都是卷积。为了使用 FFT 计算，我们需要将其中一个序列逆序。令 $p_{rev}(j) = p(m-1-j)$ 和 $p_{mask\_rev}(j) = p_{mask}(m-1-j)$。
    -   **Term A** 的计算可以通过 $S_{sq}$ 和 $p_{mask\_rev}$ 的卷积得到，其中 $S_{sq}(i) = s(i)^2$。
    -   **Term B** 的计算可以通过 $S$ 和 $p_{rev}$ 的卷积得到。

#### 3. 算法步骤

1.  **预处理**:
    *   将 $S$ 和 $P$ 转换为数值数组 $s$ 和 $p$ ('?' -> 0)。
    *   创建 $p_{mask}$ 数组。
    *   创建 $s$ 的平方数组 $s_{sq}$。
    *   计算常数 Term C。
    *   创建 $p$ 和 $p_{mask}$ 的逆序版本 $p_{rev}$ 和 $p_{mask\_rev}$。

2.  **FFT 卷积**:
    *   确定 FFT 长度 $N$，取大于等于 $n+m-1$ 的最小 2 的幂。
    *   分别计算两个卷积：
        1.  `Conv_A = IFFT(FFT(s_sq_padded) * FFT(p_mask_rev_padded))`
        2.  `Conv_B = IFFT(FFT(s_padded) * FFT(p_rev_padded))`
    *   进行必要的零填充。

3.  **计算差异度并查找**:
    *   对于每个可能的起始位置 $k \in [0, n-m]$，卷积结果位于索引 $k+m-1$ 处。
    *   计算 $D(k) = \text{Conv\_A}[k+m-1] - 2 \cdot \text{Conv\_B}[k+m-1] + \text{Term C}$。
    *   由于浮点数精度限制，检查 `abs(D(k))` 是否小于一个极小的阈值 (e.g., `1e-6`)。如果是，则位置 $k$ 是一个匹配。

### 复杂度分析

-   **预处理**: $O(n+m)$。
-   **FFT 卷积**: 涉及的 FFT 长度 $N=O(n)$ (假设 $n \gg m$)。总共需要 4 次 FFT/IFFT 和 2 次向量乘法，复杂度为 $O(N \log N) = O(n \log n)$。
-   **最终计算**: $O(n)$。

**总体时间复杂度为 $O(n \log n)$**。

### 优化思路

1.  **FFT 打包 (FFT Packing)**: 将两个实数序列（如 $s$ 和 $s_{sq}$）放入一个复数序列的实部和虚部，可以用一次复数 FFT 计算两个实数 FFT，将计算量减少近一半。

2.  **数论变换 (Number-Theoretic Transform, NTT)**: 在有限域（模一个大素数）上进行整数运算，完全避免了浮点数精度问题。对于需要精确匹配的场景是更优的选择。

3.  **分块处理 (Blocking)**: 若主串 $S$ 极大，导致内存不足，可将 $S$ 分为多个重叠的块，对每个块独立进行匹配。需要妥善处理块的边界。